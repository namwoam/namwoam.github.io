---
layout: post
title: "LeetCode 1096 (Hard) 題解"
date: 2026-02-22 08:00:00 -0000
tags: [leetcode]
excerpt: ""
draft: false
---

題目連結：[1096. Brace Expansion II](https://leetcode.com/problems/brace-expansion-ii/description/)

最近我在準備某家公司的 Technical Interview ，剛好在時限壓力（兩小時內 Eazy Medium Hard 各一題）下很勉強的解出這題，想記錄一下。這題雖然邏輯上沒有很麻煩，但是實作上有蠻多細節要注意跟邊界條件要處理，Hard 實至名歸啊！

## Problem Formulation

Given a expression $$s$$, output the generated words in sorted ascending order, the experssion follows the following rule (grammer):

$$R(x) = \{x\}$$

$$R(e_1, e_2) = e_1 \cup e_2 $$

$$R(e_1 e_2) = \{a+b \: \forall (a,b) \in R(e_1) \times R(e_2) \}  $$ 

where plus denotes concatation and cross denotes cartesian product.

## Examples

#### Example 1

> Input: `{a,b}`
>
> Output: `["a","b"]`

#### Example 2

> Input: `a{b,c}`
>
> Output: `["ab","ac"]`

#### Example 3

> Input: `{a,b}{c,{d,e}}`
>
> Output: `["ac","ad","ae","bc","bd","be"]`

#### Example 4

> Input: `{a,a{b,c},{ab,z}}`
>
> Output: `["a","ab","ac","z"]`

## Solution

在寫這題的時候，我覺得 parsing 這些括號、逗號的結構會沒有那麼好寫，尤其這些 operation 也沒有限制一定會是二元的，我當下想不太到什麼很好的方法把 expression 切成一個樹狀的結構。但是假設你成功取出來這些 set 之後，他們之間的交互作用是相對好實作的，因此快速的實作以下兩個 function：

```py
def set_and(s1: set[str], s2: set[str]) -> set[str]:
    return s1.union(s2)
```

```py
def set_addition(s1: set[str], s2: set[str]) -> set[str]:
    if len(s1) == 0 and len(s2) == 0:
        return set()
    elif len(s1) == 0:
        return s2
    elif len(s2) == 0:
        return s1
    st = set()
    for v1 in s1:
        for v2 in s2:
            st.add(v1+v2)
    return st
```

有了這兩個 function 了之後，就可以來開始實作 parser 的部分。

分別觀察 *Example 3* 與 *Example 4* ，我們可以發現不論多複雜的 expression ，它最外圈的 operation 也必定是 addition 或是 and 的其中之一。使用變數 `cnt` 紀錄括號 opening 和 enclosing 的數量，我們就可以把 expression 分解成一個個 segment。

```py
cnt = 0
start_pos = 0
segments = []
for i in range(len(exp)):
    if (exp[i] == "{"):
        cnt += 1
    elif (exp[i] == "}"):
        cnt -= 1
    if (cnt == 0):
        segments.append(exp[start_pos:i+1])
        start_pos = i+1
segments.append(exp[start_pos: len(exp)])
segments = [segment for segment in segments if len(segment) > 0]
```

要注意在這樣的邏輯下，如果最外圍的 operation 是 and 的話，則會有 segment 是單獨一個逗號。比方說 `{x,a{b,c}}` 會被分解成 `["x", ",", "a", "{b,c}"]`。這裡還要處理的 edgecase 是 `a{b,c}` 被我們不正確的拆分成 `a` 和 `{b,c}`，要把中間沒有逗號的 segments 合併為同一個。

反之亦然，如果最外圍的 operation 是 addition 的話，則不會有任何一個 segment 是單獨一個逗號，比方說 `a{c,d}` 就會被分解成 `["a", "{c,d}"]`。

在拆分完各個 segment 之後，就可以用遞迴的方式取出各個 segment 所對應的 set ，並使用前面實作好的 function 計算這兩種 operation 的結果：

```python
# for addition operation
sets = [parse(segment) for segment in segments]
output_set = set()
for st in sets:
    result = set_addition(result, st)
return result
```

```python
# for and operation
sets = [parse(segment) for segment in segments]
output_set = set()
for st in sets:
    output_set = set_and(result, st)
return result
```

並為遞迴 function `parse` 加上 base case，就可以計算出正確的 set 並成功 AC 啦，

```python
def parse(exp: str) -> set[str]:
    if ("{" not in exp) and ("}" not in exp) and ("," not in exp):
        st = set()
        st.add(exp)
        return st
    # omitted rest
```

## Time and Space Complexity

這題的複雜度我覺得還滿難估的，因為 addition 的複雜度是非常高的，極端狀況下假設有像 `{a,b}{c,d}{e,f}{g,h}` 這樣整串都是 addition 的 expression 的話，時間和空間的複雜度都會是 $$O(n!)$$ (Where $$n$$ is the length of the expression $$s$$)

## Remarks

我平常自己估算解一題 Hard 大概會需要兩到三小時，有時間壓力下真的會解比較快，就算沒有想到什麼優雅的解法（比方說做一棵 Abstract Syntax Tree 出來），但看到時間在倒數計時就會有莫名的壓力，就會逼自己用比較繁瑣的寫法也要做出來。深深體會 Make it work 可是比 Make it fast/pretty 還要優先呢。